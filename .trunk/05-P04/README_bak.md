## Http Producer Consumer

Using pythons fast api, implement a producer / consumer framework that will store data generated by producers, as well as provide said data to clients making requests. The data from the producers will be stored in a simulated shared memory location which will only be accessible by obtaining some kind of locking mechanism first.

This project is not very hard, so don't overthink it. We will expand on this project for our next one, adding the ability to synchronize events over the network. For now, we are only locking the "shared memory" managed by the server.

### Server

-   Waits and listens on a port for "clients" to send data or request data.
-   Should print messages to the console as incoming requests are received.
-   Should use threads to respond to incoming requests by producers and consumers.
-   Uses a locking mechanism to access "shared memory"

### Clients

-   Two types of "clients"
    1. Producer
        - Produces (in our case) instructions that alter shared memory.
    2. Consumer
        - Consumes values from shared memory
-   Clients will initiate a network connection with the server, and then either send data or request data, depending on which type they are.

### Producers

Generate instructions:

ADD 27 N
SET 97 I

### Shared Memory

```python
sharedMem = {
    'A': 0,
    'B': 0,
    'C': 0,
    'D': 0,
    'E': 0,
    'F': 0,
    'G': 0,
    'H': 0,
    'I': 0,
    'J': 0,
    'K': 0,
    'L': 0,
    'M': 0,
    'N': 0,
    'O': 0,
    'P': 0,
    'Q': 0,
    'R': 0,
    'S': 0,
    'T': 0,
    'U': 0,
    'V': 0,
    'W': 0,
    'X': 0,
    'Y': 0,
    'Z': 0
}
```

You need to have a shared data structure
There should be one producer thread. It should add random strings of text (from 4-10 characters long) to the data structure. (add 100 of them)
There should be 2 consumer threads. Each thread should remove a string from the shared data structure, and then print the string along with some identification of the thread which did the consuming.
All three threads should, of course, be running in parallel.

https://realpython.com/intro-to-python-threading/

https://medium.com/geekculture/distributed-lock-implementation-with-redis-and-python-22ae932e10ee

https://www.laurentluce.com/posts/python-threads-synchronization-locks-rlocks-semaphores-conditions-events-and-queues/
