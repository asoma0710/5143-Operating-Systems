## Project X - File System Simulation / Virtualization
#### Due: TBD

To Create a virtual or simulated file system without the need for writing low-level device drivers which interact with actual devices is a little different, but possible. Some methods for making this happen are listed below. You will discover my preferred solution by reading the numbered list below. You do not have to use my preferred solution, but you will have to justify with a one page document why you feel that your choice (which doesn't necessarily need to be listed below) is the best.

1. **In-Memory File System**: You can create a file system that operates entirely in memory without interacting with physical storage devices. This approach allows you to define your own data structures to represent files, directories, and their relationships. File operations can be implemented using standard data manipulation techniques. While the data is stored in memory, this approach can simulate the behavior and features of a file system. The drawbacks are that when your program stops running, your file system disappears, unless its serialized and saved to non-volatile memory (some kind of disk).

2. **File System Abstraction Layer**: Instead of creating a full-fledged file system, you can design an abstraction layer that provides a uniform interface for interacting with different file systems or storage mechanisms. This layer can abstract away the low-level details and provide a consistent API for file operations. It allows you to switch between different underlying storage mechanisms without modifying the higher-level code. I'm not sure that there are any drawbacks to using this method since our ultimate goal is to `simulate` a file system, and we are not worried about performance. However, this really results in creating a class that uses a library which in turn makes system calls to manipulate the existing file system. A feasible solution, but not ideal (in my mind).

3. **Virtual File System Libraries**: Utilize existing virtual file system libraries or frameworks that provide high-level abstractions for creating file systems. These libraries often offer APIs and tools to define file structures, handle file operations, and simulate the behavior of a file system. Some examples include FUSE (Filesystem in Userspace) for Unix-like systems and Dokan for Windows. This is similar to the previous solution, but with an existing library that provides most of the functionality of an existing file system. Again, not ideal for the assignment that I had in mind.

4. **Emulation/Simulation Environments**: Leverage emulation or simulation environments that provide tools and frameworks for simulating entire operating systems, including file systems. These environments can emulate the behavior of file systems at a higher level, allowing you to experiment and test file system operations without the need for low-level device drivers. This solution could work, but requires a slightly steep learning curve that is not applicable in any other situation. Meaning, you would be learning some emulation software for a file system in which you most likely will never use again. So, this solution is also not ideal for the assignment I had in mind. 

5. **Database as a File System**: (If you haven't figured it out, this is my first choice) Consider using a database system to simulate file system behavior. Store file metadata, contents, and directory structures in a database, and map file operations to corresponding database operations. This approach provides flexibility and allows you to leverage the powerful querying and indexing capabilities of databases. Learning to interact with a DB via some programming language is a skill that goes beyond this course. That's why I like this solution. It might not be the best (depending on very specific requirements), but it's the most robust compared to all the rest. 

